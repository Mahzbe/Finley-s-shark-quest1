<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Finley's Shark Quest</title>
    <style>
        #game-canvas {
            border: 2px solid black;
        }
        #puzzle-canvas {
            border: 2px solid black;
        }
    </style>
</head>
<body>
    <canvas id="game-canvas" width="400" height="400"></canvas>
    <canvas id="puzzle-canvas" width="400" height="400"></canvas>
    <div id="game-over-screen" style="display: none;">
        <h1>Game Over!</h1>
        <button id="restart-button">Restart</button>
    </div>

    <script>
        const gameCanvas = document.getElementById('game-canvas');
        const gameCtx = gameCanvas.getContext('2d');
        const puzzleCanvas = document.getElementById('puzzle-canvas');
        const puzzleCtx = puzzleCanvas.getContext('2d');

        const finley = { x: 50, y: 50, width: 20, height: 20, speed: 3 };
        const shark = { x: 350, y: 350, width: 20, height: 20, speed: 2 };
        let moveCounter = 7;
        let matches = 0;

        // Puzzle grid
        const gridRows = 6;
        const gridCols = 6;
        const blockSize = 60;
        let grid = [];

        function initGrid() {
            for (let row = 0; row < gridRows; row++) {
                grid[row] = [];
                for (let col = 0; col < gridCols; col++) {
                    grid[row][col] = Math.floor(Math.random() * 4) + 1;  // Random color from 1 to 4
                }
            }
        }

        function drawGrid() {
            for (let row = 0; row < gridRows; row++) {
                for (let col = 0; col < gridCols; col++) {
                    puzzleCtx.fillStyle = getColor(grid[row][col]);
                    puzzleCtx.fillRect(col * blockSize, row * blockSize, blockSize, blockSize);
                }
            }
        }

        function getColor(value) {
            switch (value) {
                case 1: return 'red';
                case 2: return 'green';
                case 3: return 'blue';
                case 4: return 'yellow';
                default: return 'gray';
            }
        }

        function handleBlockClick(event) {
            const rect = puzzleCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            const col = Math.floor(x / blockSize);
            const row = Math.floor(y / blockSize);
            
            // Logic to check for matches and remove blocks
            if (checkForMatches(row, col)) {
                matches++;
                if (matches >= 5) {
                    alert('You win!');
                    return;
                }
                if (--moveCounter <= 0) {
                    gameOver();
                }
            }
            drawGrid();
        }

        function checkForMatches(row, col) {
            // Simplified match checking logic for 3 in a row/column
            let match = false;
            // Horizontal check
            if (col <= gridCols - 3 && grid[row][col] === grid[row][col + 1] && grid[row][col] === grid[row][col + 2]) {
                grid[row][col] = grid[row][col + 1] = grid[row][col + 2] = 0;
                match = true;
            }
            // Vertical check
            if (row <= gridRows - 3 && grid[row][col] === grid[row + 1][col] && grid[row][col] === grid[row + 2][col]) {
                grid[row][col] = grid[row + 1][col] = grid[row + 2][col] = 0;
                match = true;
            }
            return match;
        }

        function updateGrid() {
            // Drop blocks down
            for (let col = 0; col < gridCols; col++) {
                for (let row = gridRows - 1; row >= 0; row--) {
                    if (grid[row][col] === 0) {
                        for (let aboveRow = row - 1; aboveRow >= 0; aboveRow--) {
                            if (grid[aboveRow][col] !== 0) {
                                grid[row][col] = grid[aboveRow][col];
                                grid[aboveRow][col] = 0;
                                break;
                            }
                        }
                    }
                }
            }
            // Refill top rows
            for (let row = 0; row < gridRows; row++) {
                for (let col = 0; col < gridCols; col++) {
                    if (grid[row][col] === 0) {
                        grid[row][col] = Math.floor(Math.random() * 4) + 1;
                    }
                }
            }
        }

        puzzleCanvas.addEventListener('click', handleBlockClick);

        function gameOver() {
            document.getElementById('game-over-screen').style.display = 'block';
        }

        function restartGame() {
            document.getElementById('game-over-screen').style.display = 'none';
            finley.x = 50;
            finley.y = 50;
            shark.x = 350;
            shark.y = 350;
            moveCounter = 7;
            matches = 0;
            initGrid();
            drawGrid();
            gameLoop();
        }

        document.getElementById('restart-button').addEventListener('click', restartGame);

        function updateGame() {
            // Update Finley movement logic
            if (finley.x < gameCanvas.width - finley.width && finley.y === 50) {
                finley.x += finley.speed;
            } else if (finley.x >= gameCanvas.width - finley.width && finley.y < gameCanvas.height - finley.height) {
                finley.y += finley.speed;
            } else if (finley.y >= gameCanvas.height - finley.height && finley.x > 50) {
                finley.x -= finley.speed;
            } else if (finley.x <= 50 && finley.y > 50) {
                finley.y -= finley.speed;
            }

            // Shark movement
            if (moveCounter <= 0) {
                if (shark.x < finley.x) {
                    shark.x += shark.speed;
                } else if (shark.x > finley.x) {
                    shark.x -= shark.speed;
                }
                if (shark.y < finley.y) {
                    shark.y += shark.speed;
                } else if (shark.y > finley.y) {
                    shark.y -= shark.speed;
                }

                // Check collision between Finley and Shark
                if (shark.x < finley.x + finley.width && shark.x + shark.width > finley.x &&
                    shark.y < finley.y + finley.height && shark.y + shark.height > finley.y) {
                    gameOver();
                }
            }
        }

        function renderGame() {
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

            // Draw Finley
            gameCtx.fillStyle = 'green';
            gameCtx.fillRect(finley.x, finley.y, finley.width, finley.height);

            // Draw Shark
            gameCtx.fillStyle = 'red';
            gameCtx.fillRect(shark.x, shark.y, shark.width, shark.height);
        }

        function gameLoop() {
            updateGame();
            renderGame();
            requestAnimationFrame(gameLoop);
        }

        // Initialize the game
        initGrid();
        drawGrid();
        gameLoop();
    </script>
</body>
</html>
