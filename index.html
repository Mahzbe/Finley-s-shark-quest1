<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Finley's Shark Quest</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #000;
            color: #fff;
        }
        #game-canvas {
            display: block;
            background-color: #333;
            margin: 0 auto;
        }
        #start-menu, #game-over-screen {
            text-align: center;
            color: #fff;
        }
        #puzzle-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 10px;
        }
        #puzzle-grid {
            display: grid;
            grid-template-columns: repeat(4, 50px);
            gap: 5px;
        }
        .puzzle-piece {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
        }
        #timer {
            font-size: 24px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <canvas id="game-canvas" width="800" height="500"></canvas>
    <div id="puzzle-container">
        <div id="puzzle-grid"></div>
        <div id="timer">Moves Left: 7</div>
    </div>
    <div id="start-menu">
        <h1>Finley's Shark Quest</h1>
        <button id="start-button" onclick="startGame()">Start Game</button>
    </div>
    <div id="game-over-screen" style="display: none;">
        <h1>Game Over!</h1>
        <p>Your score: <span id="final-score"></span></p>
        <p id="game-status"></p>
        <button id="restart-button" onclick="restartGame()">Restart</button>
    </div>

    <script>
        let game, canvas, ctx, puzzleGridElement, timerElement;
        const colors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange'];
        let selectedPiece = null;
        let timerInterval;

        function initGame() {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            puzzleGridElement = document.getElementById('puzzle-grid');
            timerElement = document.getElementById('timer');
            
            game = {
                shark: {
                    speed: 2,
                    x: 400,
                    y: 300,
                    width: 50,
                    height: 50
                },
                finley: {
                    speed: 3,
                    x: 100,
                    y: 100,
                    width: 50,
                    height: 50,
                    targetCorner: 0 // Start with the first corner (top-left)
                },
                score: 0,
                gameOver: false,
                moves: 7, // Initialize move limit
                matches: 0,
                puzzleGrid: generatePuzzleGrid(),
                timer: 7 // Initialize timer
            };

            renderPuzzleGrid();
            startTimer();
        }

        function startGame() {
            document.getElementById("start-menu").style.display = "none";
            initGame();
            gameLoop();
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                if (game.gameOver) return;

                game.timer--;
                timerElement.textContent = `Moves Left: ${game.timer}`;

                if (game.timer <= 0) {
                    clearInterval(timerInterval);
                    gameOver();
                }
            }, 1000);
        }

        function updateShark() {
            const deltaX = game.finley.x - game.shark.x;
            const deltaY = game.finley.y - game.shark.y;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            const speed = game.shark.speed;
            game.shark.x += (deltaX / distance) * speed;
            game.shark.y += (deltaY / distance) * speed;
        }

        function updateFinley() {
            const corners = [
                { x: 0, y: 0 },
                { x: canvas.width - game.finley.width, y: 0 },
                { x: canvas.width - game.finley.width, y: canvas.height - game.finley.height },
                { x: 0, y: canvas.height - game.finley.height }
            ];

            const target = corners[game.finley.targetCorner];

            if (game.finley.x < target.x) {
                game.finley.x += game.finley.speed;
            } else if (game.finley.x > target.x) {
                game.finley.x -= game.finley.speed;
            }

            if (game.finley.y < target.y) {
                game.finley.y += game.finley.speed;
            } else if (game.finley.y > target.y) {
                game.finley.y -= game.finley.speed;
            }

            if (Math.abs(game.finley.x - target.x) < 5 && Math.abs(game.finley.y - target.y) < 5) {
                game.finley.targetCorner = (game.finley.targetCorner + 1) % 4;
            }
        }

        function updateGame() {
            if (game.gameOver) return;

            updateShark();
            updateFinley();

            if (checkCollision(game.finley, game.shark)) {
                gameOver();
            }

            if (!game.puzzleSolved) {
                checkPuzzleSolved();
            }
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = 'green';
            ctx.fillRect(game.finley.x, game.finley.y, game.finley.width, game.finley.height);

            ctx.fillStyle = 'red';
            ctx.fillRect(game.shark.x, game.shark.y, game.shark.width, game.shark.height);

            ctx.fillStyle = 'white';
            ctx.fillText(`Score: ${game.score}`, 10, 10);
        }

        function gameLoop() {
            updateGame();
            render();
            if (!game.gameOver) {
                requestAnimationFrame(gameLoop);
            }
        }

        function gameOver() {
            game.gameOver = true;
            document.getElementById("game-over-screen").style.display = "block";
            document.getElementById("final-score").innerText = game.score;
            document.getElementById("game-status").innerText = `You ${game.matches >= 5 ? 'won' : 'lost'} the game!`;
            if (game.timer <= 0) {
                document.getElementById("game-status").innerText += ' Time ran out!';
            }
        }

        function restartGame() {
            document.getElementById("game-over-screen").style.display = "none";
            clearInterval(timerInterval);
            initGame();
            gameLoop();
        }

        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.height > obj2.y;
        }

        function generatePuzzleGrid() {
            const grid = [];
            for (let i = 0; i < 4; i++) {
                const row = [];
                for (let j = 0; j < 4; j++) {
                    row.push(colors[Math.floor(Math.random() * colors.length)]);
                }
                grid.push(row);
            }
            return grid;
        }

        function renderPuzzleGrid() {
            puzzleGridElement.innerHTML = '';
            game.puzzleGrid.forEach((row, rowIndex) => {
                row.forEach((color, colIndex) => {
                    const piece = document.createElement('div');
                    piece.className = 'puzzle-piece';
                    piece.style.backgroundColor = color;
                    piece.dataset.row = rowIndex;
                    piece.dataset.col = colIndex;
                    piece.addEventListener('click', handleBlockClick);
                    puzzleGridElement.appendChild(piece);
                });
            });
        }

        function handleBlockClick(event) {
            if (game.gameOver) return;

            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);

            if (selectedPiece) {
                const selectedRow = parseInt(selectedPiece.dataset.row);
                const selectedCol = parseInt(selectedPiece.dataset.col);

                // Swap blocks if they are adjacent
                if ((Math.abs(selectedRow - row) === 1 && selectedCol === col) || 
                    (Math.abs(selectedCol - col) === 1 && selectedRow === row)) {
                    // Perform swap
                    [game.puzzleGrid[row][col], game.puzzleGrid[selectedRow][selectedCol]] =
                        [game.puzzleGrid[selectedRow][selectedCol], game.puzzleGrid[row][col]];

                    // Check for matches
                    checkMatches();
                    game.moves--;

                    if (game.moves <= 0 && !game.puzzleSolved) {
                        gameOver();
                    }

                    // Clear selection
                    selectedPiece.classList.remove('selected');
                    selectedPiece = null;
                } else {
                    // Select new piece
                    if (selectedPiece) {
                        selectedPiece.classList.remove('selected');
                    }
                    event.target.classList.add('selected');
                    selectedPiece = event.target;
                }
            } else {
                // Select new piece
                event.target.classList.add('selected');
                selectedPiece = event.target;
            }
        }

        function checkMatches() {
            let matched = false;

            // Horizontal matches
            for (let i = 0; i < 4; i++) {
                let matchLength = 1;
                for (let j = 1; j < 4; j++) {
                    if (game.puzzleGrid[i][j] === game.puzzleGrid[i][j - 1]) {
                        matchLength++;
                    } else {
                        if (matchLength >= 3) {
                            matched = true;
                            removeMatchedBlocks(i, j - matchLength, 'horizontal', matchLength);
                        }
                        matchLength = 1;
                    }
                }
                if (matchLength >= 3) {
                    matched = true;
                    removeMatchedBlocks(i, 4 - matchLength, 'horizontal', matchLength);
                }
            }

            // Vertical matches
            for (let j = 0; j < 4; j++) {
                let matchLength = 1;
                for (let i = 1; i < 4; i++) {
                    if (game.puzzleGrid[i][j] === game.puzzleGrid[i - 1][j]) {
                        matchLength++;
                    } else {
                        if (matchLength >= 3) {
                            matched = true;
                            removeMatchedBlocks(i - matchLength, j, 'vertical', matchLength);
                        }
                        matchLength = 1;
                    }
                }
                if (matchLength >= 3) {
                    matched = true;
                    removeMatchedBlocks(4 - matchLength, j, 'vertical', matchLength);
                }
            }

            if (matched) {
                dropBlocks();
                game.score += 10;
                game.matches++;
                if (game.matches >= 5) {
                    game.puzzleSolved = true;
                }
            }
        }

        function removeMatchedBlocks(startRow, startCol, direction, length) {
            if (direction === 'horizontal') {
                for (let i = startCol; i < startCol + length; i++) {
                    game.puzzleGrid[startRow][i] = null;
                }
            } else if (direction === 'vertical') {
                for (let i = startRow; i < startRow + length; i++) {
                    game.puzzleGrid[i][startCol] = null;
                }
            }
        }

        function dropBlocks() {
            for (let col = 0; col < 4; col++) {
                let emptyRow = 3;
                for (let row = 3; row >= 0; row--) {
                    if (game.puzzleGrid[row][col] !== null) {
                        game.puzzleGrid[emptyRow][col] = game.puzzleGrid[row][col];
                        emptyRow--;
                    }
                }
                for (let i = emptyRow; i >= 0; i--) {
                    game.puzzleGrid[i][col] = colors[Math.floor(Math.random() * colors.length)];
                }
            }
            renderPuzzleGrid(); // Re-render puzzle grid
        }
    </script>
</body>
</html>
