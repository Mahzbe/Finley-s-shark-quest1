<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Finley's Shark Quest</title>
    <style>
        #game-canvas {
            display: none;
        }
        #start-menu, #game-over-screen {
            text-align: center;
        }
        .block {
            width: 50px;
            height: 50px;
            display: inline-block;
            margin: 1px;
        }
        #puzzle-grid {
            display: grid;
            grid-template-columns: repeat(4, 50px);
            grid-template-rows: repeat(4, 50px);
            margin-top: 20px;
        }
        #shark, #finley {
            position: absolute;
            width: 50px;
            height: 50px;
        }
        #shark {
            background-color: red;
        }
        #finley {
            background-color: green;
        }
        #timer {
            text-align: center;
            font-size: 20px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <canvas id="game-canvas" width="800" height="600"></canvas>
    <div id="start-menu">
        <h1>Finley's Shark Quest</h1>
        <button id="start-button" onclick="startGame()">Start Game</button>
    </div>
    <div id="game-over-screen" style="display: none;">
        <h1>Game Over!</h1>
        <p>Your score: <span id="final-score"></span></p>
        <button id="restart-button" onclick="restartGame()">Restart</button>
    </div>
    <div id="puzzle-grid"></div>
    <div id="shark"></div>
    <div id="finley"></div>
    <div id="timer">Moves Left: <span id="move-counter">7</span></div>

    <script>
        let game = {
            level: 0,
            puzzle: {
                puzzlePieces: [],
                sharkBehavior: {
                    speed: 1,
                    aggression: 1
                }
            },
            shark: {
                speed: 1,
                aggression: 1,
                x: 700,
                y: 100
            },
            finley: {
                x: 50,
                y: 50,
                width: 50,
                height: 50
            },
            score: 0,
            puzzleGrid: [
                [null, null, null, null],
                [null, null, null, null],
                [null, null, null, null],
                [null, null, null, null]
            ],
            movesLeft: 7,
            puzzleSolved: false
        };

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        function startGame() {
            console.log("Start game button clicked!");
            document.getElementById("start-menu").style.display = "none";
            document.getElementById("game-canvas").style.display = "block";
            generatePuzzle();
            updatePuzzleGrid();
            document.getElementById('puzzle-grid').style.display = 'grid';
            document.getElementById('timer').style.display = 'block';
            gameLoop();
        }

        function generatePuzzle() {
            // Generate a 4x4 puzzle grid with random colors
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const color = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;
                    game.puzzleGrid[i][j] = color;
                }
            }
        }

        function updatePuzzleGrid() {
            const gridElement = document.getElementById('puzzle-grid');
            gridElement.innerHTML = ''; // Clear existing blocks

            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const block = document.createElement('div');
                    block.classList.add('block');
                    block.style.backgroundColor = game.puzzleGrid[i][j];
                    block.dataset.index = i * 4 + j;
                    block.onclick = handleBlockClick;
                    gridElement.appendChild(block);
                }
            }
        }

        function handleBlockClick(event) {
            if (event.target.classList.contains('block')) {
                const clickedBlock = event.target;
                const index = clickedBlock.dataset.index;
                const row = Math.floor(index / 4);
                const col = index % 4;

                // Swap block with the one above
                if (row > 0) {
                    swapBlocks(row, col, row - 1, col);
                    checkMatches();
                }

                // Update grid
                updatePuzzleGrid();
                updateMoveCounter();
            }
        }

        function swapBlocks(row1, col1, row2, col2) {
            const temp = game.puzzleGrid[row1][col1];
            game.puzzleGrid[row1][col1] = game.puzzleGrid[row2][col2];
            game.puzzleGrid[row2][col2] = temp;
        }

        function checkMatches() {
            let matches = 0;
            const matchedIndices = new Set();

            // Check for horizontal and vertical matches
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const color = game.puzzleGrid[i][j];

                    // Check horizontal
                    if (j < 2 && color === game.puzzleGrid[i][j + 1] && color === game.puzzleGrid[i][j + 2]) {
                        matchedIndices.add(i * 4 + j);
                        matchedIndices.add(i * 4 + j + 1);
                        matchedIndices.add(i * 4 + j + 2);
                        matches++;
                    }

                    // Check vertical
                    if (i < 2 && color === game.puzzleGrid[i + 1][j] && color === game.puzzleGrid[i + 2][j]) {
                        matchedIndices.add(i * 4 + j);
                        matchedIndices.add((i + 1) * 4 + j);
                        matchedIndices.add((i + 2) * 4 + j);
                        matches++;
                    }
                }
            }

            // Remove matched blocks
            if (matches >= 5) {
                game.puzzleSolved = true;
                endGame();
            } else {
                // Remove matched blocks and shift others down
                matchedIndices.forEach(index => {
                    const row = Math.floor(index / 4);
                    const col = index % 4;
                    game.puzzleGrid[row][col] = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;
                });
                updatePuzzleGrid();
            }
        }

        function updateMoveCounter() {
            game.movesLeft--;
            document.getElementById('move-counter').innerText = game.movesLeft;

            if (game.movesLeft <= 0 && !game.puzzleSolved) {
                gameOver();
            }
        }

        function endGame() {
            document.getElementById("game-over-screen").style.display = "block";
            document.getElementById("final-score").innerText = game.score;
        }

        function gameOver() {
            document.getElementById("game-over-screen").style.display = "block";
            document.getElementById("final-score").innerText = game.score;
        }

        function restartGame() {
            game.score = 0;
            game.level = 0;
            game.puzzle.puzzlePieces = [];
            game.shark.speed = 1;
            game.shark.aggression = 1;
            game.finley.x = 50;
            game.finley.y = 50;
            game.shark.x = 700;
            game.shark.y = 100;
            game.movesLeft = 7;
            game.puzzleSolved = false;
            document.getElementById("game-over-screen").style.display = "none";
            document.getElementById('puzzle-grid').style.display = 'grid';
            startGame();
        }

        function updateSharkPosition() {
            const dx = game.finley.x - game.shark.x;
            const dy = game.finley.y - game.shark.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 0) {
                const moveX = (dx / distance) * game.shark.speed;
                const moveY = (dy / distance) * game.shark.speed;
                game.shark.x += moveX;
                game.shark.y += moveY;

                game.shark.x = Math.max(0, Math.min(750, game.shark.x));
                game.shark.y = Math.max(0, Math.min(550, game.shark.y));

                document.getElementById('shark').style.left = game.shark.x + 'px';
                document.getElementById('shark').style.top = game.shark.y + 'px';
            }
        }

        function updateFinleyPosition() {
            const dx = game.shark.x - game.finley.x;
            const dy = game.shark.y - game.finley.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 0) {
                const moveX = (dx / distance) * -3;
                const moveY = (dy / distance) * -3;

                game.finley.x += moveX;
                game.finley.y += moveY;

                game.finley.x = Math.max(0, Math.min(750, game.finley.x));
                game.finley.y = Math.max(0, Math.min(550, game.finley.y));

                document.getElementById('finley').style.left = game.finley.x + 'px';
                document.getElementById('finley').style.top = game.finley.y + 'px';
            }
        }

        function gameLoop() {
            if (!game.puzzleSolved) {
                updateSharkPosition();
                updateFinleyPosition();
                checkCollisions();
                requestAnimationFrame(gameLoop);
            }
        }

        function checkCollisions() {
            if (checkCollision(game.finley, game.shark)) {
                if (game.movesLeft <= 0) {
                    endGame();
                } else {
                    gameOver();
                }
            }
        }

        function checkCollision(object1, object2) {
            if (object1.x < object2.x + object2.width &&
                object1.x + object1.width > object2.x &&
                object1.y < object2.y + object2.height &&
                object1.y + object1.height > object2.y) {
                return true;
            }
            return false;
        }
    </script>
</body>
</html>
